# vizij-animation-wasm

`vizij-animation-wasm` exposes `vizij-animation-core` to JavaScript/TypeScript via `wasm-bindgen`. The crate compiles to a
`cdylib` and ships JavaScript glue that is republished to npm as `@vizij/animation-wasm`.

## Overview

* Provides a minimal JS class (`VizijAnimation`) and a higher-level wrapper used by the npm package (`Engine`).
* Accepts both engine-native `AnimationData` JSON and the standardized `StoredAnimation` format.
* Returns outputs as JSON structures (`changes`, `events`) matching the Rust core.
* Includes parity tests against the native engine to ensure behavior matches across platforms.

## Architecture

```
Rust (vizij-animation-core)  -->  wasm-bindgen (vizij-animation-wasm)  -->  npm/@vizij/animation-wasm
          ^                               |                                         |
          |                               |                                         +-- src/index.ts (wrapper & types)
          |                               +-- js/glue generated by wasm-bindgen     +-- pkg/ (wasm-pack output)
          |
          +-- Shared JSON schemas (StoredAnimation, Value, Outputs)
```

* The crate exposes a `VizijAnimation` struct annotated with `#[wasm_bindgen]`.
* `wasm-pack` compiles the crate targeting `wasm32-unknown-unknown` and generates the JS glue code.
* The npm package re-exports the generated glue with a stable ESM entry, type definitions, and convenience helpers.

## Installation

Inside this repository build the WASM artifact and install npm dependencies:

```bash
# Build the WASM package
node scripts/build-animation-wasm.mjs

# Install and build the npm wrapper (generates type declarations, bundles helpers)
cd npm/@vizij/animation-wasm
npm install
npm run build
```

In external projects install the published npm package:

```bash
npm install @vizij/animation-wasm
```

The crate has no optional Rust features; enable the `console_error` feature when targeting the browser and you want panic hooks to
log to the console.

## Setup

1. Ensure `wasm-pack` and `wasm-bindgen-cli` are installed (`cargo install wasm-pack wasm-bindgen-cli`).
2. Run `node scripts/build-animation-wasm.mjs` to produce the `pkg/` directory under `npm/@vizij/animation-wasm/`.
3. Link or publish the npm package as needed (`npm link` for local dev with `vizij-web`).
4. In your JS/TS application call `await init()` from the npm package before constructing an engine instance.

## Usage

### JavaScript / TypeScript API

The npm wrapper exports:

* `async function init(input?: InitInput): Promise<void>` – Loads the WASM module. Optional input allows custom URLs or binary
  sources.
* `function abi_version(): number` – Returns a numeric ABI guard (currently `2`).
* `class Engine` – Ergonomic wrapper around the low-level bindings:
  * `constructor(config?: Config)` – Optional capacity hints.
  * `loadAnimation(data, opts?)` – Accepts `StoredAnimation` or `AnimationData`. Returns `AnimId`.
  * `createPlayer(name: string)` – Returns `PlayerId`.
  * `addInstance(player, anim, cfg?)` – Adds an instance with optional `InstanceCfg` JSON.
  * `prebind(resolver)` – Resolve canonical target paths to application-defined keys.
  * `updateValues(dtSeconds, inputs?)` – Steps the simulation and returns `{ changes, events }`.
  * `updateValuesWithDerivatives(dtSeconds, inputs?)` – Same as above but returns `ChangeWithDerivative` entries with optional
    derivatives.
  * `bakeAnimation(animId, config?)` – Samples baked values for a clip.
  * `bakeAnimationWithDerivatives(animId, config?)` – Samples values plus baked derivatives.
* Low-level class `VizijAnimation` mirrors the above methods with slightly more explicit JSON handling.

### StoredAnimation format

`load_stored_animation` accepts the standardized JSON format:

```ts
interface StoredAnimation {
  id?: string;
  name?: string;
  duration: number; // milliseconds
  tracks: Array<{
    id: string;
    name?: string;
    animatableId: string;
    points: Array<{
      id: string;
      stamp: number; // 0..1
      value:
        | number
        | { x: number; y: number }
        | { x: number; y: number; z: number }
        | { r: number; p: number; y: number }
        | { r: number; g: number; b: number }
        | { h: number; s: number; l: number }
        | boolean
        | string;
      transitions?: {
        in?: { x: number; y: number };
        out?: { x: number; y: number };
      };
    }>;
    settings?: { color?: string };
  }>;
  groups?: Record<string, unknown>;
}
```

Control points default to `{ out: {x: 0.42, y: 0}, in: {x: 0.58, y: 1} }` when omitted. Boolean/string tracks use step
interpolation.

## Key Details

* **Bindings and prebinding** – `prebind(resolver)` receives canonical target paths such as `"node/Transform.translation"` and
  should return the key you want in `change.key`. Return `null`/`undefined` to leave a path unresolved.
* **Outputs** – `updateValues` returns `{ changes: Change[], events: CoreEvent[] }`. `Change.value` is a tagged union (Scalar,
  Vec3, Quat, Transform, Bool, Text, etc.). Events mirror the Rust core’s playback events. Use
  `updateValuesWithDerivatives` when you need per-change derivative samples.
* **Inputs** – Optional `Inputs` payload supports player commands (Play/Pause/Seek/SetLoopMode/etc.) and per-instance updates
  (weight, time scale, enable flag, etc.).
* **ABI guard** – `abi_version()` helps consumers detect mismatches between the wasm binary and the JS wrapper. The npm package’s
  `Engine` automatically checks the value after `init()`.
* **Environment detection** – The wrapper handles Node and browser environments. Node builds read the wasm file from disk; the
  browser path fetches it relative to the module URL.

## Examples

### TypeScript example

```ts
import { init, Engine } from "@vizij/animation-wasm";

await init();
const eng = new Engine();
const animId = eng.loadAnimation({
  duration: 2000,
  tracks: [
    {
      id: "pos-x",
      animatableId: "cube/Transform.translation",
      points: [
        { id: "k0", stamp: 0.0, value: 0 },
        { id: "k1", stamp: 1.0, value: 10 },
      ],
    },
  ],
  groups: {},
}, { format: "stored" });
const playerId = eng.createPlayer("demo");
eng.addInstance(playerId, animId);
eng.prebind((path) => path); // identity mapping

const outputs = eng.updateValues(1 / 60);
const outputsWithDerivatives = eng.updateValuesWithDerivatives(1 / 60);
console.log(outputs.changes);
```

### Low-level binding example

```ts
import initWasm, { VizijAnimation, abi_version } from "@vizij/animation-wasm/pkg";

await initWasm();
console.log("ABI", abi_version());
const raw = new VizijAnimation();
const animId = raw.load_stored_animation(JSON.stringify({
  duration: 1000,
  tracks: [
    {
      id: "t0",
      animatableId: "cube/Transform.translation",
      points: [
        { id: "k0", stamp: 0.0, value: 0 },
        { id: "k1", stamp: 1.0, value: 1 },
      ],
    },
  ],
  groups: {},
}));
const player = raw.create_player("demo");
raw.add_instance(player, animId, null);
const result = raw.update_values(0.016, null);
console.log(result);
```

## Testing

Run the Node-based test runner from the workspace root:

```bash
scripts/run-wasm-tests.sh
```

This script builds the crate for `wasm32-unknown-unknown`, generates JS glue, and executes the tests (which compare outputs to the
native engine). Browser-focused tests exist behind `wasm_bindgen_test_configure!(run_in_browser)` and can be run with
`wasm-pack test --headless --firefox` or `--chrome` if needed.

## Troubleshooting

* **“Call init() first” errors** – Ensure `await init()` resolves before constructing `Engine`/`VizijAnimation`.
* **ABI mismatch** – Rebuild the WASM package and the npm wrapper so the binary and JS glue agree on the ABI number.
* **Missing default export** – The npm wrapper re-exports both default and named bindings. If you consume the raw `pkg/`, make
  sure to import `init` appropriately.
* **Vite warnings about `node:` modules** – Safe to ignore; Node-only modules are tree-shaken in browser builds.
