# vizij-animation-wasm

`vizij-animation-wasm` exposes `vizij-animation-core` to JavaScript/TypeScript via `wasm-bindgen`. The crate compiles to a
`cdylib` and ships JavaScript glue that is republished to npm as `@vizij/animation-wasm`.

## Overview

* Provides a minimal JS class (`VizijAnimation`) and a higher-level wrapper used by the npm package (`Engine`).
* Accepts both engine-native `AnimationData` JSON and the standardized `StoredAnimation` format.
* Returns outputs as JSON structures (`changes`, `events`) matching the Rust core.
* Includes parity tests against the native engine to ensure behavior matches across platforms.

## Architecture

```
Rust (vizij-animation-core)  -->  wasm-bindgen (vizij-animation-wasm)  -->  npm/@vizij/animation-wasm
          ^                               |                                         |
          |                               |                                         +-- src/index.ts (wrapper & types)
          |                               +-- js/glue generated by wasm-bindgen     +-- pkg/ (wasm-pack output)
          |
          +-- Shared JSON schemas (StoredAnimation, Value, Outputs)
```

* The crate exposes a `VizijAnimation` struct annotated with `#[wasm_bindgen]`.
* `wasm-pack` compiles the crate targeting `wasm32-unknown-unknown` and generates the JS glue code.
* The npm package re-exports the generated glue with a stable ESM entry, type definitions, and convenience helpers.

## Installation

Inside this repository build the WASM artifact and install npm dependencies:

```bash
# Build the WASM package
node scripts/build-animation-wasm.mjs

# Install and build the npm wrapper (generates type declarations, bundles helpers)
cd npm/@vizij/animation-wasm
npm install
npm run build
```

In external projects install the published npm package:

```bash
npm install @vizij/animation-wasm
```

The crate has no optional Rust features; enable the `console_error` feature when targeting the browser and you want panic hooks to
log to the console.

## Setup

1. Ensure `wasm-pack` and `wasm-bindgen-cli` are installed (`cargo install wasm-pack wasm-bindgen-cli`).
2. Run `node scripts/build-animation-wasm.mjs` to produce the `pkg/` directory under `npm/@vizij/animation-wasm/`.
3. Link or publish the npm package as needed (`npm link` for local dev with `vizij-web`).
4. In your JS/TS application call `await init()` from the npm package before constructing an engine instance.

## Usage

### JavaScript / TypeScript API

The npm wrapper exports:

* `async function init(input?: InitInput): Promise<void>` – Loads the WASM module. Optional input allows custom URLs or binary
  sources.
* `function abi_version(): number` – Returns a numeric ABI guard (currently `2`).
* `class Engine` – Ergonomic wrapper around the low-level bindings (guards against stale WASM exports and throws with rebuild
  instructions when a function is missing):
  * `constructor(config?: Config)` – Optional capacity hints.
  * `loadAnimation(data, opts?)` – Accepts `StoredAnimation` or `AnimationData`. Returns `AnimId`.
  * `createPlayer(name: string)` – Returns `PlayerId`.
  * `addInstance(player, anim, cfg?)` – Adds an instance with optional `InstanceCfg` JSON.
  * `prebind(resolver)` – Resolve canonical target paths to application-defined keys.
  * `updateValues(dtSeconds, inputs?)` – Steps the simulation and returns `{ changes, events }`.
  * `updateValuesAndDerivatives(dtSeconds, inputs?)` – Same as above but each change also includes an optional `derivative` field.
  * `bakeAnimation(animId, cfg?)` – Returns baked samples for a clip.
  * `bakeAnimationWithDerivatives(animId, cfg?)` – Returns `{ values, derivatives }` with aligned track ordering.
  * `update(...)` – Alias for `updateValues(...)` for backwards compatibility.
* Low-level class `VizijAnimation` mirrors the above methods with slightly more explicit JSON handling.

### StoredAnimation format

`load_stored_animation` accepts the standardized JSON format:

```ts
interface StoredAnimation {
  id?: string;
  name?: string;
  duration: number; // milliseconds
  tracks: Array<{
    id: string;
    name?: string;
    animatableId: string;
    points: Array<{
      id: string;
      stamp: number; // 0..1
      value:
        | number
        | { x: number; y: number }
        | { x: number; y: number; z: number }
        | { r: number; p: number; y: number }
        | { r: number; g: number; b: number }
        | { h: number; s: number; l: number }
        | boolean
        | string;
      transitions?: {
        in?: { x: number; y: number };
        out?: { x: number; y: number };
      };
    }>;
    settings?: { color?: string };
  }>;
  groups?: Record<string, unknown>;
}
```

Control points default to `{ out: {x: 0.42, y: 0}, in: {x: 0.58, y: 1} }` when omitted. Boolean/string tracks use step
interpolation.

## Key Details

* **Bindings and prebinding** – `prebind(resolver)` receives canonical target paths such as `"node/Transform.translation"` and
  should return the key you want in `change.key`. Return `null`/`undefined` to leave a path unresolved.
* **Outputs** – `updateValues` returns `{ changes: Change[], events: CoreEvent[] }`. `updateValuesAndDerivatives` mirrors that
  shape but each change also carries an optional `derivative` value for numeric tracks. Events mirror the Rust core’s playback
  events.
* **Derivative estimation** – Finite differences sample the track at `u ± epsilon` (default epsilon `1e-3`). Bool/Text tracks
  emit `null` derivatives and quaternion derivatives are currently component-wise (TODO: angular velocity mapping).
* **Inputs** – Optional `Inputs` payload supports player commands (Play/Pause/Seek/SetLoopMode/etc.) and per-instance updates
  (weight, time scale, enable flag, etc.).
* **Baking config** – `{ frame_rate?, start_time?, end_time?, derivative_epsilon? }`. Invalid values (non-positive frame rate,
  `end_time < start_time`, invalid epsilon) throw during parsing. When provided, `derivative_epsilon` overrides the finite
  difference window used while baking.
* **ABI guard** – `abi_version()` helps consumers detect mismatches between the wasm binary and the JS wrapper. The npm package’s
  `Engine` automatically checks the value after `init()` and throws with rebuild instructions if mismatched.
* **Environment detection** – The wrapper handles Node and browser environments. Node builds read the wasm file from disk; the
  browser path fetches it relative to the module URL.

## Examples

### TypeScript example

```ts
import { init, Engine } from "@vizij/animation-wasm";

await init();
const eng = new Engine();
const animId = eng.loadAnimation({
  duration: 2000,
  tracks: [
    {
      id: "pos-x",
      animatableId: "cube/Transform.translation",
      points: [
        { id: "k0", stamp: 0.0, value: 0 },
        { id: "k1", stamp: 1.0, value: 10 },
      ],
    },
  ],
  groups: {},
}, { format: "stored" });
const playerId = eng.createPlayer("demo");
eng.addInstance(playerId, animId);
eng.prebind((path) => path); // identity mapping

const outputs = eng.updateValues(1 / 60);
console.log(outputs.changes);

const withDerivatives = eng.updateValuesAndDerivatives(1 / 60);
console.log(withDerivatives.changes.map((c) => ({ key: c.key, derivative: c.derivative ?? null })));

const baked = eng.bakeAnimationWithDerivatives(animId, {
  frame_rate: 60,
  derivative_epsilon: 5e-4,
});
console.log(baked.values.tracks[0].values.length, baked.derivatives.tracks[0].values.length);
```

### Low-level binding example

```ts
import initWasm, { VizijAnimation, abi_version } from "@vizij/animation-wasm/pkg";

await initWasm();
console.log("ABI", abi_version());
const raw = new VizijAnimation();
const animId = raw.load_stored_animation(JSON.stringify({
  duration: 1000,
  tracks: [
    {
      id: "t0",
      animatableId: "cube/Transform.translation",
      points: [
        { id: "k0", stamp: 0.0, value: 0 },
        { id: "k1", stamp: 1.0, value: 1 },
      ],
    },
  ],
  groups: {},
}));
const player = raw.create_player("demo");
raw.add_instance(player, animId, null);
const result = raw.update_values(0.016, null);
console.log(result);
```

## Testing

Run the Node-based test runner from the workspace root:

```bash
scripts/run-wasm-tests.sh
```

This script builds the crate for `wasm32-unknown-unknown`, generates JS glue, and executes the tests (which compare outputs to the
native engine). Browser-focused tests exist behind `wasm_bindgen_test_configure!(run_in_browser)` and can be run with
`wasm-pack test --headless --firefox` or `--chrome` if needed.

## Troubleshooting

* **“Call init() first” errors** – Ensure `await init()` resolves before constructing `Engine`/`VizijAnimation`.
* **ABI mismatch** – Rebuild the WASM package and the npm wrapper so the binary and JS glue agree on the ABI number.
* **Missing default export** – The npm wrapper re-exports both default and named bindings. If you consume the raw `pkg/`, make
  sure to import `init` appropriately.
* **Vite warnings about `node:` modules** – Safe to ignore; Node-only modules are tree-shaken in browser builds.
