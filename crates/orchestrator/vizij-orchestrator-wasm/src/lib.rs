use js_sys::Function;
use serde::Deserialize;
use serde_wasm_bindgen as swb;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsError;

use vizij_api_core::{json, TypedPath};
use vizij_orchestrator::{
    controllers::animation::AnimationControllerConfig, controllers::graph::GraphControllerConfig,
    scheduler::Schedule, Orchestrator,
};
mod normalize;

/// Minimal options accepted by the JS constructor.
#[derive(Default, Deserialize)]
struct OrchestratorOptions {
    pub schedule: Option<String>,
}

/// Simple JS resolver wrapper that calls a JS Function resolver(path) -> string|number|null
struct JsResolver {
    f: Function,
}

impl vizij_animation_core::TargetResolver for JsResolver {
    fn resolve(&mut self, path: &str) -> Option<String> {
        let arg = JsValue::from_str(path);
        match self.f.call1(&JsValue::UNDEFINED, &arg) {
            Ok(val) => {
                if val.is_undefined() || val.is_null() {
                    return None;
                }
                if let Some(s) = val.as_string() {
                    return Some(s);
                }
                if let Some(n) = val.as_f64() {
                    return Some(if n.fract() == 0.0 {
                        format!("{}", n as i64)
                    } else {
                        format!("{}", n)
                    });
                }
                // Last-resort: try serde conversion to String
                swb::from_value::<String>(val).ok()
            }
            Err(_) => None,
        }
    }
}

#[derive(Deserialize)]
struct JsGraphConfig {
    #[serde(default)]
    id: Option<String>,
    spec: serde_json::Value,
    #[serde(default)]
    subs: Option<JsGraphSubscriptions>,
}

#[derive(Default, Deserialize)]
struct JsGraphSubscriptions {
    #[serde(default)]
    inputs: Vec<String>,
    #[serde(default)]
    outputs: Vec<String>,
    #[serde(default)]
    #[serde(rename = "mirrorWrites", alias = "mirror_writes")]
    mirror_writes: Option<bool>,
}

fn map_graph_subscriptions(
    cfg: Option<JsGraphSubscriptions>,
) -> Result<vizij_orchestrator::controllers::graph::Subscriptions, String> {
    let mut subs = vizij_orchestrator::controllers::graph::Subscriptions::default();
    if let Some(conf) = cfg {
        subs.inputs = conf
            .inputs
            .into_iter()
            .map(|s| {
                TypedPath::parse(&s)
                    .map_err(|e| format!("invalid input subscription '{}': {}", s, e))
            })
            .collect::<Result<_, _>>()?;
        subs.outputs = conf
            .outputs
            .into_iter()
            .map(|s| {
                TypedPath::parse(&s)
                    .map_err(|e| format!("invalid output subscription '{}': {}", s, e))
            })
            .collect::<Result<_, _>>()?;
        if let Some(mirror) = conf.mirror_writes {
            subs.mirror_writes = mirror;
        }
    }
    Ok(subs)
}

#[wasm_bindgen]
pub struct VizijOrchestrator {
    core: Orchestrator,
    // counters for autogenerated ids
    graph_counter: u32,
    anim_counter: u32,
}

#[wasm_bindgen]
impl VizijOrchestrator {
    /// Create new orchestrator. Accepts optional { schedule: "SinglePass"|"TwoPass"|"RateDecoupled" }.
    #[wasm_bindgen(constructor)]
    pub fn new(opts: JsValue) -> Result<VizijOrchestrator, JsError> {
        #[cfg(feature = "console_error")]
        console_error_panic_hook::set_once();

        let options: OrchestratorOptions = if opts.is_undefined() || opts.is_null() {
            OrchestratorOptions::default()
        } else {
            swb::from_value(opts).map_err(|e| JsError::new(&format!("config parse error: {e}")))?
        };

        let schedule = match options.schedule.as_deref() {
            Some("SinglePass") | None => Schedule::SinglePass,
            Some("TwoPass") => Schedule::TwoPass,
            Some("RateDecoupled") => Schedule::RateDecoupled,
            Some(other) => {
                return Err(JsError::new(&format!("unknown schedule option: {}", other)))
            }
        };

        Ok(VizijOrchestrator {
            core: Orchestrator::new(schedule),
            graph_counter: 0,
            anim_counter: 0,
        })
    }

    /// Register a graph controller.
    ///
    /// Accepts either:
    ///  - a string containing the GraphSpec JSON, or
    ///  - an object { id?: string, spec: object } where spec is a GraphSpec-compatible object.
    ///
    /// Returns the controller id.
    #[wasm_bindgen(js_name = register_graph)]
    pub fn register_graph(&mut self, cfg: JsValue) -> Result<String, JsError> {
        if cfg.is_undefined() || cfg.is_null() {
            return Err(JsError::new("register_graph: cfg required"));
        }

        // If cfg is a string, parse it as JSON text into serde_json::Value
        let (id, mut spec_val, subs_val) = if cfg.is_string() {
            // Treat as raw JSON string
            let s = cfg.as_string().unwrap();
            let v: serde_json::Value = serde_json::from_str(&s)
                .map_err(|e| JsError::new(&format!("graph json parse error: {}", e)))?;
            (None, v, None)
        } else {
            // Treat as object { id?: string, spec: object }
            let obj: JsGraphConfig = swb::from_value(cfg)
                .map_err(|e| JsError::new(&format!("graph cfg parse error: {}", e)))?;
            (obj.id, obj.spec, obj.subs)
        };

        json::normalize_graph_spec_value(&mut spec_val);

        // Deserialize GraphSpec
        let spec: vizij_graph_core::types::GraphSpec = serde_json::from_value(spec_val)
            .map_err(|e| JsError::new(&format!("graph spec deserialize error: {}", e)))?;

        let subs = map_graph_subscriptions(subs_val)
            .map_err(|e| JsError::new(&format!("graph subscriptions error: {e}")))?;

        // Generate id if needed
        let id = match id {
            Some(s) => s,
            None => {
                let gid = format!("graph:{}", self.graph_counter);
                self.graph_counter = self.graph_counter.wrapping_add(1);
                gid
            }
        };

        // Build controller config and insert into orchestrator
        let cfg = GraphControllerConfig {
            id: id.clone(),
            spec,
            subs,
        };
        let controller = vizij_orchestrator::controllers::graph::GraphController::new(cfg);
        self.core.graphs.insert(id.clone(), controller);

        Ok(id)
    }

    /// Register an animation controller.
    ///
    /// Accepts an object { id?: string, setup?: any } where setup is forwarded to the
    /// AnimationControllerConfig.setup field.
    /// Returns the controller id.
    #[wasm_bindgen(js_name = register_animation)]
    pub fn register_animation(&mut self, cfg: JsValue) -> Result<String, JsError> {
        if cfg.is_undefined() || cfg.is_null() {
            return Err(JsError::new("register_animation: cfg required"));
        }
        let obj: serde_json::Value = swb::from_value(cfg)
            .map_err(|e| JsError::new(&format!("animation cfg parse error: {}", e)))?;
        let id_opt = obj
            .get("id")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        let setup = obj.get("setup").cloned().unwrap_or(serde_json::Value::Null);

        let id = match id_opt {
            Some(s) => s,
            None => {
                let aid = format!("anim:{}", self.anim_counter);
                self.anim_counter = self.anim_counter.wrapping_add(1);
                aid
            }
        };

        let cfg = AnimationControllerConfig {
            id: id.clone(),
            setup,
        };
        let controller =
            vizij_orchestrator::controllers::animation::AnimationController::try_new(cfg)
                .map_err(|e| JsError::new(&format!("animation setup error: {e}")))?;
        self.core.anims.insert(id.clone(), controller);
        Ok(id)
    }

    /// Resolve canonical target paths using a JS resolver function.
    ///
    /// The resolver should be `function(path: string): string|number|null|undefined`.
    /// For each registered animation controller we call engine.prebind(&mut JsResolver).
    #[wasm_bindgen]
    pub fn prebind(&mut self, resolver: Function) {
        let mut js_resolver = JsResolver { f: resolver };
        for (_id, anim) in self.core.anims.iter_mut() {
            // Engine::prebind expects &mut dyn TargetResolver
            // swallow errors from JS resolver as the animation wasm does
            anim.engine.prebind(&mut js_resolver);
        }
    }

    /// Set a blackboard input value (convenience).
    ///
    /// `value_json` and `shape_json` should be JS objects compatible with the core Value/Shape JSON shapes.
    #[wasm_bindgen(js_name = set_input)]
    pub fn set_input(
        &mut self,
        path: &str,
        value_json: JsValue,
        shape_json: JsValue,
    ) -> Result<(), JsError> {
        let value: serde_json::Value = swb::from_value(value_json)
            .map_err(|e| JsError::new(&format!("value parse error: {}", e)))?;
        let shape_opt: Option<serde_json::Value> =
            if shape_json.is_null() || shape_json.is_undefined() {
                None
            } else {
                Some(
                    swb::from_value(shape_json)
                        .map_err(|e| JsError::new(&format!("shape parse error: {}", e)))?,
                )
            };
        self.core
            .blackboard
            .set(
                path.to_string(),
                value,
                shape_opt,
                self.core.epoch,
                "host".to_string(),
            )
            .map_err(|e| JsError::new(&format!("blackboard set error: {}", e)))?;
        Ok(())
    }

    /// Remove an input key from the blackboard. Returns true if removed.
    #[wasm_bindgen(js_name = remove_input)]
    pub fn remove_input(&mut self, path: &str) -> bool {
        self.core.blackboard.remove(path).is_some()
    }

    /// Step the orchestrator by dt seconds and return an OrchestratorFrame as a JS value.
    #[wasm_bindgen]
    pub fn step(&mut self, dt: f32) -> Result<JsValue, JsError> {
        let frame = self
            .core
            .step(dt)
            .map_err(|e| JsError::new(&format!("step error: {}", e)))?;
        swb::to_value(&frame).map_err(|e| JsError::new(&format!("serialize frame error: {}", e)))
    }

    /// List registered controllers (ids).
    #[wasm_bindgen(js_name = list_controllers)]
    pub fn list_controllers(&self) -> Result<JsValue, JsError> {
        let graphs: Vec<String> = self.core.graphs.keys().cloned().collect();
        let anims: Vec<String> = self.core.anims.keys().cloned().collect();
        let mut out = serde_json::Map::new();
        out.insert(
            "graphs".to_string(),
            serde_json::Value::Array(graphs.into_iter().map(serde_json::Value::String).collect()),
        );
        out.insert(
            "anims".to_string(),
            serde_json::Value::Array(anims.into_iter().map(serde_json::Value::String).collect()),
        );
        swb::to_value(&serde_json::Value::Object(out))
            .map_err(|e| JsError::new(&format!("list_controllers serialize: {}", e)))
    }

    /// Remove a registered graph controller by id.
    #[wasm_bindgen(js_name = remove_graph)]
    pub fn remove_graph(&mut self, id: &str) -> bool {
        self.core.graphs.shift_remove(id).is_some()
    }

    /// Remove a registered animation controller by id.
    #[wasm_bindgen(js_name = remove_animation)]
    pub fn remove_animation(&mut self, id: &str) -> bool {
        self.core.anims.shift_remove(id).is_some()
    }
}

#[wasm_bindgen(js_name = normalize_graph_spec_json)]
pub fn normalize_graph_spec_json(json: &str) -> Result<JsValue, JsError> {
    match crate::normalize::normalize_graph_spec_json(json) {
        Ok(s) => Ok(JsValue::from_str(&s)),
        Err(e) => Err(JsError::new(&format!(
            "normalize_graph_spec_json error: {}",
            e
        ))),
    }
}

/// ABI version for compatibility checks.
#[wasm_bindgen]
pub fn abi_version() -> u32 {
    2
}
